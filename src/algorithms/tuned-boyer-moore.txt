1.  const ASIZE = 256;
2.  
3.  export function myAlgorithm(text, pattern) {
4.    function preBmBc(pattern, m, bmBc) {
5.      for (let i = 0; i < ASIZE; ++i) {
6.        bmBc[i] = m;
7.      }
8.  
9.      for (let i = 0; i < m - 1; ++i) {
10.       bmBc[pattern.charCodeAt(i)] = m - i - 1;
11.     }
12.   }
13. 
14.   function memset(text, character, m) {
15.     let aux = "";
16. 
17.     for (let i = 0; i < m; i++) {
18.       aux += character;
19.     }
20. 
21.     return text + aux;
22.   }
23. 
24.   function memcmp(text, j, m, pattern) {
25.     for (let i = 0; i < m; i++) {
26.       if (text[j + i] !== pattern[i]) {
27.         return false;
28.       }
29.     }
30. 
31.     return true;
32.   }
33. 
34.   function TUNEDBM(pattern, m, text, n) {
35.     let j, k, shift;
36.     const bmBc = new Array(ASIZE);
37.     const indices = [];
38. 
39.     preBmBc(pattern, m, bmBc);
40.     shift = bmBc[pattern.charCodeAt(m - 1)];
41.     bmBc[pattern.charCodeAt(m - 1)] = 0;
42. 
43.     text = memset(text, pattern[m - 1], m);
44. 
45.     j = 0;
46. 
47.     while (j <= n - m) {
48.       k = bmBc[text.charCodeAt(j + m - 1)];
49. 
50.       while (k !== 0) {
51.         j += k;
52.         k = bmBc[text.charCodeAt(j + m - 1)];
53.         j += k;
54.         k = bmBc[text.charCodeAt(j + m - 1)];
55.         j += k;
56.         k = bmBc[text.charCodeAt(j + m - 1)];
57.       }
58. 
59.       if (j <= n - m && memcmp(text, j, m, pattern)) {
60.         indices.push(j);
61.       }
62. 
63.       j += shift;
64.     }
65. 
66.     return indices;
67.   }
68. 
69.   const n = text.length;
70.   const m = pattern.length;
71.   const indices = TUNEDBM(pattern, m, text, n);
72. 
73.   return indices;
74. }
